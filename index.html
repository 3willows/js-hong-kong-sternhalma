<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Chinese Checkers</title>
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="grid" id="grid"></div>

  <script>
    const rows = 5, cols = 20;
    let selectedPiece = null;
    const grid = document.getElementById('grid');

    // Initialize board
    function createBoard() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;

          // Add starting pieces
          if (col < 2 && row * 2 + col < 10) {  // Player 1 (left)
            const piece = createPiece('player1');
            cell.appendChild(piece);
          }
          if (col >= cols - 2 && (row * 2 + (cols - col - 1)) < 10) {  // Player 2 (right)
            const piece = createPiece('player2');
            cell.appendChild(piece);
          }

          cell.addEventListener('click', handleClick);
          grid.appendChild(cell);
        }
      }
    }

    function createPiece(playerClass) {
      const piece = document.createElement('div');
      piece.className = `piece ${playerClass}`;
      return piece;
    }

    function handleClick(e) {
      const cell = e.currentTarget;
      const piece = cell.querySelector('.piece');
      if (selectedPiece) {
        if (cell.classList.contains('valid-move')) {
          // Check if it's a jump move
          const rowDiff = Math.abs(selectedPiece.row - parseInt(cell.dataset.row));
          const colDiff = Math.abs(selectedPiece.col - parseInt(cell.dataset.col));

          // If moving more than 2 spaces, it's a jump
          if (rowDiff >= 2 || colDiff >= 2) {
            // Calculate jumped piece position
            const jumpedRow = (selectedPiece.row + parseInt(cell.dataset.row)) / 2;
            const jumpedCol = (selectedPiece.col + parseInt(cell.dataset.col)) / 2;
            const jumpedCell = getCell(jumpedRow, jumpedCol);
          }

          movePiece(selectedPiece, cell);
          clearSelection();
        } else {
          clearSelection();
        }
      } else if (piece) {
        selectedPiece = {
          element: piece,
          row: parseInt(cell.dataset.row),
          col: parseInt(cell.dataset.col)
        };
        piece.classList.add('selected');
        showValidMoves(cell);
      }
    }

    function showValidMoves(fromCell) {
      const startRow = parseInt(fromCell.dataset.row);
      const startCol = parseInt(fromCell.dataset.col);
      const visited = new Map(); // Tracks minimum jumps to reach each cell
      const queue = [[startRow, startCol, 0]]; // [row, col, jumps]

      // Clear previous valid moves
      document.querySelectorAll('.valid-move').forEach(c => {
        c.classList.remove('valid-move');
      });

      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1], [0, 1],
        [1, -1], [1, 0], [1, 1]
      ];

      function isPathClear(startR, startC, endR, endC) {
        const dr = Math.sign(endR - startR);
        const dc = Math.sign(endC - startC);
        let r = startR + dr;
        let c = startC + dc;

        while (r !== endR || c !== endC) {
          if (getCell(r, c).querySelector('.piece')) return false;
          r += dr;
          c += dc;
        }
        return true;
      }

      // Process jump moves with BFS
      while (queue.length > 0) {
        const [row, col, jumps] = queue.shift();
        const key = `${row},${col}`;

        // Skip if we've already found a better path
        if (visited.has(key) && visited.get(key) <= jumps) continue;
        visited.set(key, jumps);

        for (const [dr, dc] of directions) {
          let step = 1;
          while (true) {
            const checkRow = row + dr * step;
            const checkCol = col + dc * step;

            if (!isValidCell(checkRow, checkCol)) break;

            const checkCell = getCell(checkRow, checkCol);
            if (checkCell.querySelector('.piece')) {
              if (isPathClear(row, col, checkRow, checkCol)) {
                const jumpRow = row + dr * (step * 2);
                const jumpCol = col + dc * (step * 2);

                if (isValidCell(jumpRow, jumpCol)) {
                  const jumpKey = `${jumpRow},${jumpCol}`;
                  const totalJumps = jumps + 1;
                  const jumpCell = getCell(jumpRow, jumpCol);

                  if (!jumpCell.querySelector('.piece') &&
                    (!visited.has(jumpKey) || totalJumps < visited.get(jumpKey))) {
                    queue.push([jumpRow, jumpCol, totalJumps]);
                    jumpCell.classList.add('valid-move');

                    // Remove existing jump number first to prevent duplicates
                    const existingNumber = jumpCell.querySelector('.jump-number');
                    if (existingNumber) existingNumber.remove();

                    const jumpNumber = document.createElement('span');
                    jumpNumber.className = 'jump-number';
                    jumpNumber.textContent = totalJumps;
                    jumpCell.appendChild(jumpNumber);
                  }

                }
              }
              break;
            }
            step++;
          }
        }
      }

      // Add single-step moves (0 jumps)
      for (const [dr, dc] of directions) {
        const targetRow = startRow + dr;
        const targetCol = startCol + dc;
        if (isValidCell(targetRow, targetCol)) {
          const cell = getCell(targetRow, targetCol);
          if (!cell.querySelector('.piece')) {
            cell.classList.add('valid-move');
          }
        }
      }

      // Merge and prioritize lower jump counts
      visited.forEach((jumps, key) => {
        const [row, col] = key.split(',').map(Number);
        const cell = getCell(row, col);
        if (cell.textContent === '' || jumps < parseInt(cell.textContent)) {
          const jumpNumber = document.createElement('span');
          jumpNumber.textContent = jumps.toString();
        }
      });
    }




    function movePiece(from, toCell) {
      toCell.appendChild(from.element);
      from.element.classList.remove('selected');
    }

    function clearSelection() {
      document.querySelectorAll('.valid-move').forEach(c => {
        c.classList.remove('valid-move')
      });
      document.querySelectorAll('.jump-number').forEach(n => n.remove());
      if (selectedPiece) {
        selectedPiece.element.classList.remove('selected');
        selectedPiece = null;
      }
    }

    function isValidCell(row, col) {
      return row >= 0 && row < rows && col >= 0 && col < cols;
    }

    function getCell(row, col) {
      return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    }

    createBoard();
  </script>
</body>

</html>