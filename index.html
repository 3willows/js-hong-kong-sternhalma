<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Chinese Checkers</title>
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="grid" id="grid"></div>

  <script>
    const rows = 5, cols = 20;
    let selectedPiece = null;
    const grid = document.getElementById('grid');

    // Initialize board
    function createBoard() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;

          // Add starting pieces
          if (col < 2 && row * 2 + col < 10) {  // Player 1 (left)
            const piece = createPiece('player1');
            cell.appendChild(piece);
          }
          if (col >= cols - 2 && (row * 2 + (cols - col - 1)) < 10) {  // Player 2 (right)
            const piece = createPiece('player2');
            cell.appendChild(piece);
          }

          cell.addEventListener('click', handleClick);
          grid.appendChild(cell);
        }
      }
    }

    function createPiece(playerClass) {
      const piece = document.createElement('div');
      piece.className = `piece ${playerClass}`;
      return piece;
    }

    function handleClick(e) {
      const cell = e.currentTarget;
      const piece = cell.querySelector('.piece');

      if (selectedPiece) {
        if (cell.classList.contains('valid-move')) {
          // Check if it's a jump move
          const rowDiff = Math.abs(selectedPiece.row - parseInt(cell.dataset.row));
          const colDiff = Math.abs(selectedPiece.col - parseInt(cell.dataset.col));

          // If moving 2 spaces, it's a jump
          if (rowDiff === 2 || colDiff === 2) {
            // Calculate jumped piece position
            const jumpedRow = (selectedPiece.row + parseInt(cell.dataset.row)) / 2;
            const jumpedCol = (selectedPiece.col + parseInt(cell.dataset.col)) / 2;
            const jumpedCell = getCell(jumpedRow, jumpedCol);

            // You could add logic here to handle jumped pieces
            // (e.g., remove them in Checkers-style games)
          }

          movePiece(selectedPiece, cell);
          clearSelection();
        } else {
          clearSelection();
        }
      } else if (piece) {
        selectedPiece = {
          element: piece,
          row: parseInt(cell.dataset.row),
          col: parseInt(cell.dataset.col)
        };
        piece.classList.add('selected');
        showValidMoves(cell);
      }
    }

    function showValidMoves(fromCell) {
      const startRow = parseInt(fromCell.dataset.row);
      const startCol = parseInt(fromCell.dataset.col);
      const visited = new Set();
      const queue = [[startRow, startCol]];
      visited.add(`${startRow},${startCol}`);

      // Clear previous valid moves
      document.querySelectorAll('.valid-move').forEach(c => c.classList.remove('valid-move'));

      // Check all 8 possible directions (orthogonal + diagonal)
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1], [0, 1],
        [1, -1], [1, 0], [1, 1]
      ];

      while (queue.length > 0) {
        const [row, col] = queue.shift();

        // Check all directions from current position
        for (const [dr, dc] of directions) {
          let step = 1;
          while (true) {
            // Check intermediate positions
            const checkRow = row + dr * step;
            const checkCol = col + dc * step;

            if (!isValidCell(checkRow, checkCol)) break;

            const checkCell = getCell(checkRow, checkCol);
            if (checkCell.querySelector('.piece')) {
              // Calculate jump landing position
              const jumpRow = row + dr * (step * 2);
              const jumpCol = col + dc * (step * 2);

              if (isValidCell(jumpRow, jumpCol)) {
                const jumpCell = getCell(jumpRow, jumpCol);
                const jumpKey = `${jumpRow},${jumpCol}`;

                if (!jumpCell.querySelector('.piece') && !visited.has(jumpKey)) {
                  jumpCell.classList.add('valid-move');
                  visited.add(jumpKey);
                  queue.push([jumpRow, jumpCol]); // Allow chained jumps
                }
              }
              break; // Only consider first piece in this direction
            }
            step++;
          }
        }
      }

      // Also show adjacent single-step moves
      for (const [dr, dc] of directions) {
        const targetRow = startRow + dr;
        const targetCol = startCol + dc;
        if (isValidCell(targetRow, targetCol)) {
          const cell = getCell(targetRow, targetCol);
          if (!cell.querySelector('.piece')) {
            cell.classList.add('valid-move');
          }
        }
      }
    }



    function movePiece(from, toCell) {
      toCell.appendChild(from.element);
      from.element.classList.remove('selected');
    }

    function clearSelection() {
      document.querySelectorAll('.valid-move').forEach(c => c.classList.remove('valid-move'));
      if (selectedPiece) {
        selectedPiece.element.classList.remove('selected');
        selectedPiece = null;
      }
    }

    function isValidCell(row, col) {
      return row >= 0 && row < rows && col >= 0 && col < cols;
    }

    function getCell(row, col) {
      return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    }

    createBoard();
  </script>
</body>

</html>